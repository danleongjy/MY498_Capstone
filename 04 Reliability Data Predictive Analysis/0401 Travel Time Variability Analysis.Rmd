---
title: "0401 Travel Time Variability Analysis"
output: html_notebook
---

```{r include = FALSE}
wd = "~/msc applied social data science/data/London/TfL/TfL API/Travel Options"
library(dplyr)
library(tidyr)
library(dbplyr)
library(ggplot2)
```

## Data Prep
### Read in AM peak baseline fastest option data
```{r}
db <- DBI::dbConnect(RSQLite::SQLite(), paste0(wd,'/20190322_0830/traveloptions.db'))
baseline_traveloptions <- tbl(db, 'traveloptions')
baseline_fastestoption <- tbl(db, sql('SELECT orig_id, dest_id, option_id, MIN(traveltime) FROM (SELECT orig_id, dest_id, option_id, traveltime FROM traveloptions WHERE legs_cycle = 0) GROUP BY orig_id, dest_id'))
baseline_fastestoption <- left_join(baseline_fastestoption, baseline_traveloptions, by = c('orig_id', 'dest_id', 'option_id')) %>% collect()
baseline_fastestoption$`MIN(traveltime)` <- NULL

# clean up
colnames(baseline_fastestoption)[c(30,31,32,42:47)] <- c('dist_nationalrail', 'legs_nationalrail', 'time_nationalrail', 'dist_riverbus', 'legs_riverbus', 'time_riverbus', 'dist_replacementbus', 'legs_replacementbus', 'time_replacementbus') # rename columns to remove dashes
dist_columns <- colnames(baseline_fastestoption)[ which(substr(colnames(baseline_fastestoption), 1, 4) == 'dist')] # convert distances to km
baseline_fastestoption[,dist_columns] <- baseline_fastestoption[,dist_columns] / 1000
rm(baseline_traveloptions, dist_columns)
DBI::dbDisconnect(db)
```
Successfully read `r nrow(baseline_fastestoption)` OD pairs of data. Available columns: `r colnames(baseline_fastestoption)`.

### Read in observed AM peak fastest option data for 983 origins and 7 destinations
```{r}
## obtain directories
dirs <- list.dirs(wd, recursive = F)
dirs <- dirs[(1:length(dirs))[substr(dirs, nchar(wd) + 41, nchar(wd) + 47) == 'ampeak']]

## compile data
obs <- data.frame()
obs_i <- 1
for (dir in dirs) {
  if ('traveloptions_to_cityplus6clusters.db' %in% list.files(dir)) {
    db <- DBI::dbConnect(RSQLite::SQLite(), paste0(dir,'/traveloptions_to_cityplus6clusters.db'))
    fastestoption <- tbl(db, sql('SELECT orig_id, dest_id, MIN(traveltime) FROM (SELECT orig_id, dest_id, traveltime FROM traveloptions WHERE legs_cycle = 0) GROUP BY orig_id, dest_id')) %>% collect()
    fastestoption$obs_i <- obs_i
    obs_i <- obs_i + 1
    DBI::dbDisconnect(db)
    
    obs <- rbind(obs, fastestoption)
  }
}

## clean up
rm(fastestoption)
rm(db, dir, dirs, obs_i)
colnames(obs) <- c('orig_id', 'dest_id', 'traveltime', 'obs')
```
Successfully read `r nrow(obs)` observations of actual trip options.

```{r}
## calculate statistics of observed distribution of travel times and generate regressiondf
odpair_traveltime <- obs %>% group_by(orig_id,dest_id) %>% summarise(median_traveltime = quantile(traveltime, .5), traveltime_5pc = quantile(traveltime, .05), traveltime_95pc = quantile(traveltime, .95))
regressiondf <- left_join(odpair_traveltime, baseline_fastestoption, by = c('orig_id','dest_id'))
regressiondf$traveltime_95pc_minus_median <- regressiondf$traveltime_95pc - regressiondf$median_traveltime
regressiondf$traveltime_95pc_minus_5pc <- regressiondf$traveltime_95pc - regressiondf$traveltime_5pc
regressiondf$traveltime_95pc_minus_baseline <- regressiondf$traveltime_95pc - regressiondf$traveltime
```

Successfully compiled `r nrow(regressiondf)` OD pairs of data on the distribution of observed travel times.  Available columns: `r colnames(regressiondf)`

### Construct travel time matrix
```{r warning = F}
ttm_baseline_fastestoption <- baseline_fastestoption[,c('orig_id','dest_id','traveltime')] %>% filter(dest_id %in% c('E02000001','E02000384','E02000455','E02000558','E02000649','E02000664','E02000779')) %>% spread(key = 'dest_id', value = 'traveltime')
rownames(ttm_baseline_fastestoption) <- ttm_baseline_fastestoption$orig_id
ttm_baseline_fastestoption$orig_id <- NULL
ttm_baseline_fastestoption[c(1:5),c(1:5)] # print first 5 x 5 square of data
```

### Calculate similarity of travel times between all pairs of MSOAs based on Euclidean Distance of travel times to 7 destinations
```{r}
dist_baseline_fastestoption <- as.matrix(dist(ttm_baseline_fastestoption))
dim(dist_baseline_fastestoption)
dist_baseline_fastestoption[c(1:5),c(1:5)] # print first 5 x 5 square of data
```
### Helper functions for regressions
```{r}
# function to prep dataframes to contain the results
prep_results_containers <- function(distance_matrix, regressiondf, ivs) {
  results_coef <- data.frame(matrix(nrow = nrow(distance_matrix), ncol = length(ivs)), row.names = rownames(distance_matrix))
  colnames(results_coef) <- ivs
  results_pval <- results_coef
  results_localrsqadj <- data.frame(local_rsq = rep(NA,nrow(ttm_baseline_fastestoption)), row.names = rownames(distance_matrix))
  results_predictions <- data.frame(matrix(nrow = nrow(regressiondf), ncol = length(ivs)), row.names = rownames(regressiondf))
  colnames(results_predictions) <- ivs
  results_containers_list <- list(results_coef, results_pval, results_localrsqadj, results_predictions)
  names(results_containers_list) <- c('results_coef', 'results_pval', 'results_localrsqadj', 'results_predictions')
  return(results_containers_list)
}

# function to carry out LWR
locally_weighted_regression <- function(regressiondf, ivs, dv, distance_matrix, results_containers_list, criticalquantile = 1) {
  rowsprocessed = 0
  print(paste('Processing local regression for', nrow(distance_matrix), 'areas.'))
  lm_formula <- as.formula(paste(dv, '~', paste(ivs, collapse = ' + ')))

  for (orig in rownames(distance_matrix)) {
    criticaldist <- quantile(distance_matrix[orig,], criticalquantile)
    localcluster <- names(distance_matrix[orig,])[which(distance_matrix[orig,] <= criticaldist)]
    regressiondf_local <- regressiondf %>% filter(orig_id %in% localcluster)

    lm_local <- lm(lm_formula, data = regressiondf_local)
    lm_local_summary <- summary(lm_local)$coefficients
    
    # assign local coef estimates to results
    for (dv in ivs[c(2:length(ivs))]) {
      results_containers_list$results_coef[orig,dv] <- lm_local_summary[,1][dv]
    }
    results_containers_list$results_coef[orig,'1'] <- lm_local_summary['(Intercept)',1]

    # assign local coef pvals to results
    for (dv in ivs[c(2:length(ivs))]) {
      results_containers_list$results_pval[orig,dv] <- lm_local_summary[,4][dv]
    }
    results_containers_list$results_pval[orig,'1'] <- lm_local_summary['(Intercept)',4]
    
    # assign local rsq to results
    results_containers_list$results_localrsqadj[orig,] <- summary(lm_local)$r.squared
    
    # monitor progress
    rowsprocessed <- rowsprocessed + 1
    if (rowsprocessed %% 100 == 0) {
      print(rowsprocessed)
    }
    
  }
  # predict DV based on local regression coefficients
  print('Predicting DV values')
  results_coef_for_join <- results_containers_list$results_coef
  results_coef_for_join$orig_id <- rownames(results_containers_list$results_coef)
  regressiondf_results <- regressiondf[,c('orig_id', 'dest_id', ivs[2:length(ivs)])] %>% left_join(results_coef_for_join, by = 'orig_id')
  results_containers_list$results_predictions[,'1'] <- regressiondf_results[,'1']
  
  for (dv in ivs[2:length(ivs)]) {
    results_containers_list$results_predictions[,dv] <- regressiondf_results[,paste0(dv,'.x')] * regressiondf_results[,paste0(dv,'.y')]
  }
  results_containers_list$results_predictions$prediction <- rowSums(results_containers_list$results_predictions, na.rm = T)
  print('Completed.')
  return(results_containers_list)
}

# function to plot outputs
plot_results <- function(regressiondf, results_predictions, dv, title, xlabel, ylabel) {
  pseudo_rsq <- round(1 - sum((unlist(regressiondf[,dv]) - results_predictions$prediction)^2) / sum((unlist(regressiondf[,dv]) - mean(unlist(regressiondf[,dv])))^2), 2)
  plot(unlist(regressiondf[,dv]), results_predictions$prediction, xlab = xlabel, ylab = ylabel)
  lines(c(0,200),c(0,200), col = 'red')
  title(paste(c(title, '| Spearman Corr:', round(cor(regressiondf[,dv], results_predictions$prediction, method = 'spearman'), 2), '| Pseudo Rsq:', pseudo_rsq), collapse = ' '))
}
```
## OLS Regression with Local Spillovers
### Prepare weighted mean of DV for neighbours of each area
```{r}
dv <- 'traveltime_95pc_minus_median'

regressiondf$dv_local_mean <- 0
for (row in 1:nrow(regressiondf)) {
  orig <- regressiondf[row,]$orig_id
  dest <- regressiondf[row,]$dest_id
  criticaltime <- quantile(dist_baseline_fastestoption[orig,], .005) # 5 nearest neighbours
  localcluster <- names(dist_baseline_fastestoption[orig,])[which(dist_baseline_fastestoption[orig,] <= criticaltime)]
  localcluster <- setdiff(localcluster, orig) # exclude current pair from local cluster
  dv_local_mean <- regressiondf[,c('orig_id','dest_id',dv)] %>% filter(orig_id %in% localcluster & dest_id == dest)
  regressiondf[row,]$dv_local_mean <- mean(unlist(dv_local_mean[,dv]))
}

plot(unlist(regressiondf[,dv]), regressiondf$dv_local_mean, xlab = '90% HPD Interval Width', ylab = 'Local Mean of 90% HPD Interval Width')
title(paste(c('Pearson Correlation between Interval Width and\nLocal Mean Interval Width:', round(cor(regressiondf[,dv], regressiondf$dv_local_mean), 2)), collapse = ''))
```
```{r include = FALSE}
library(rgdal)
library(tmap)
```
### Read in spatial data
```{r results = 'hide'}
msoas <- readOGR(dsn = '../90 Data/GLA', layer = 'MSOA_2011_London_gen_MHW') # read in MSOAs shapefile
msoas <- spTransform(msoas, CRS('+init=epsg:27700')) # reproject to British National Grid
msoas <- msoas[,'MSOA11CD']
londontube <- readOGR(dsn = '../90 Data/misc', layer = 'londontube')
londontube <- spTransform(londontube, CRS('+init=epsg:27700'))
londonrail <- readOGR(dsn = '../90 Data/misc', layer = 'Tracks')
londonrail <- spTransform(londonrail, CRS('+init=epsg:27700'))
```
### Visualise calculation of local mean for Stratford, E02000726
```{r fig.width = 9, fig.height = 8}
# compile data for Stratford
stratford_localcluster <- data.frame(dist_baseline_fastestoption['E02000726',])
colnames(stratford_localcluster) <- 'euclidean_dist'
stratford_localcluster$'MSOA Type' <- 'Excluded from Locally Weighted Regression (LWR)'
stratford_localcluster[ which(stratford_localcluster$euclidean_dist < quantile(stratford_localcluster$euclidean_dist, .03)),]$'MSOA Type' <- 'Included in LWR'
stratford_localcluster[ which(stratford_localcluster$euclidean_dist < quantile(stratford_localcluster$euclidean_dist, .005)),]$'MSOA Type' <- 'Included in LWR and Local Mean RBT Calculation'
stratford_localcluster['E02000726','MSOA Type'] <- 'Stratford: Included in LWR'

# compile data for 7 destinations
destinations <- msoas %>% subset(MSOA11CD %in% c('E02000001','E02000384','E02000455','E02000558','E02000649','E02000664','E02000779'))

# join to spatial data
stratford_localcluster_spatial <- msoas
stratford_localcluster_spatial@data <- left_join(stratford_localcluster_spatial@data, tibble::rownames_to_column(stratford_localcluster), by = c('MSOA11CD' = 'rowname'))

# plot map
tmap_mode('plot') # set to plotting mode
tm_shape(stratford_localcluster_spatial) + 
  tm_polygons('MSOA Type', palette = 'Paired') +
tm_shape(destinations) + 
  tm_borders(col = 'red') +
tm_shape(londontube) + 
  tm_lines(lwd = .1, col = 'black') +
tm_shape(londonrail) + 
  tm_lines(lwd = .1, col = 'black') +
tm_layout(legend.position = c('left','bottom'), outer.margins = c(0,0,0,0), frame = F)
```


### Declare regression variables
```{r}
ivs <- c('1','dv_local_mean','transfers','dist_bus','dist_coach','dist_dlr','dist_nationalrail','dist_overground','dist_riverbus','dist_tflrail','dist_tram','dist_tube','dist_walking')
lm_formula <- as.formula(paste(dv, '~', paste(ivs, collapse = ' + ')))
```
### Execute OLS Regression with Local Spillovers

```{r}
lm_global_local_spillovers <- lm(lm_formula, data = regressiondf)
summary(lm_global_local_spillovers)
```
If neighbours' 90% HPD interval widths are high, then own interval width also tends to be high.  After controlling for this, increased reliance on bus, National Rail and Overground tend to increase the interval width, while tram tends to decrease the interval width.

## Locally Weighted Regression with Local Spillovers
### Set up dataframes to store results
```{r}
results_lwr02 <- prep_results_containers(dist_baseline_fastestoption, regressiondf, ivs)
```
### Carry out locally weighted regression
```{r}
results_lwr02 <- locally_weighted_regression(regressiondf, ivs, dv, dist_baseline_fastestoption, results_lwr02, .03)
```

```{r}
plot_results(regressiondf, results_lwr02$results_predictions, dv, 'Locally Weighted Regression with Local Spillovers\n', xlabel = 'Actual 90% HPD Interval Width', ylabel = 'Predicted 90% HPD Interval Width')
```
```{r fig.height = 5, fig.width = 10}
par(mfrow = c(1,2))
plot_results(regressiondf, data.frame(prediction = lm_global_local_spillovers$fitted.values), dv, 'OLS with Spillovers\n', xlabel = 'Actual 90% HPD Interval Width', ylabel = 'Predicted 90% HPD Interval Width')
plot_results(regressiondf, results_lwr02$results_predictions, dv, 'LWR with Spillovers\n', xlabel = 'Actual 90% HPD Interval Width', ylabel = 'Predicted 90% HPD Interval Width')
```
## Visualisation of Coefficients
### join results
```{r}
results_lwr02_coefs_spatial <- msoas # creating a copy to work with
results_lwr02_coefs_spatial@data <- left_join(results_lwr02_coefs_spatial@data, tibble::rownames_to_column(results_lwr02$results_coef), by = c('MSOA11CD' = 'rowname')) # joining results to spatial
rownames(results_lwr02_coefs_spatial@data) <- results_lwr02_coefs_spatial@data$MSOA11CD # shift MSOA IDs to rownames
results_lwr02_coefs_spatial@data$MSOA11CD <- NULL
colnames(results_lwr02_coefs_spatial@data) <- c('Intercept', 'Local Mean RBT', 'Transfers', 'Bus km', 'Coach km', 'DLR km', 'National Rail km', 'Overground km', 'Riverbus km', 'TfL Rail km', 'Tram km', 'Underground km', 'Walking km')

results_lwr02_pvals_spatial <- msoas # creating a copy to work with
results_lwr02_pvals_spatial@data <- left_join(results_lwr02_pvals_spatial@data, tibble::rownames_to_column(results_lwr02$results_pval), by = c('MSOA11CD' = 'rowname')) # joining results to spatial
rownames(results_lwr02_pvals_spatial@data) <- results_lwr02_pvals_spatial@data$MSOA11CD # shift MSOA IDs to rownames
results_lwr02_pvals_spatial@data$MSOA11CD <- NULL
colnames(results_lwr02_pvals_spatial@data) <- c('Intercept', 'Local Mean RBT', 'Transfers', 'Bus km', 'Coach km', 'DLR km', 'National Rail km', 'Overground km', 'Riverbus km', 'TfL Rail km', 'Tram km', 'Underground km', 'Walking km')

results_lwr02_localrsqadj_spatial <- msoas # creating a copy to work with
results_lwr02_localrsqadj_spatial@data <- left_join(results_lwr02_localrsqadj_spatial@data, tibble::rownames_to_column(results_lwr02$results_localrsqadj), by = c('MSOA11CD' = 'rowname')) # joining results to spatial
rownames(results_lwr02_localrsqadj_spatial@data) <- results_lwr02_localrsqadj_spatial@data$MSOA11CD # shift MSOA IDs to rownames
results_lwr02_localrsqadj_spatial@data$MSOA11CD <- NULL
colnames(results_lwr02_localrsqadj_spatial@data) <- c('Local Rsq Adj')

# masking away coef estimates if pval < .1
# using https://stackoverflow.com/questions/39412241/uncover-values-of-one-data-frame-with-another-mask-data-frame
is.na(results_lwr02_coefs_spatial@data) <- !as.matrix(results_lwr02_pvals_spatial@data < .1)

```
### Visualise data
```{r fig.width = 18, fig.height = 24}
tmap_mode('plot') # set to plotting mode
tm_shape(results_lwr02_coefs_spatial) + 
  tm_fill(c(colnames(results_lwr02_coefs_spatial@data)), palette = '-RdYlGn') +
tm_shape(londontube) + 
  tm_lines(lwd = .1, col = 'black') +
tm_shape(londonrail) + 
  tm_lines(lwd = .1, col = 'black') + 
tm_facets(ncol = 3, nrow = ceiling(ncol(results_lwr02_coefs_spatial) / 3), sync = T) + 
tm_layout(legend.position = c('left','bottom'), outer.margins = c(0,0,0,0), frame = F, legend.text.size = 1.5, legend.title.size = 1.5)
```
```{r fig.width = 9, fig.height = 8}
tmap_mode('plot') # set to plotting mode
tm_shape(results_lwr02_localrsqadj_spatial) + 
  tm_fill('local_rsq', palette = 'Greens') +
tm_shape(londontube) + 
  tm_lines(lwd = .1, col = 'black') +
tm_shape(londonrail) + 
  tm_lines(lwd = .1, col = 'black') +
tm_layout(main.title = 'Adjusted Rsq for Local Regression Fit', main.title.position = 'center', legend.position = c('left','bottom'))
```

```{r fig.width = 24, fig.height = 18}
tmap_mode('plot') # set to plotting mode
tm_shape(results_lwr02_pvals_spatial) + 
  tm_fill(c(colnames(results_lwr02_pvals_spatial@data)), palette = 'Blues', style = 'fixed', breaks = c(0,.01,.05,.1,1)) +
tm_shape(londontube) + 
  tm_lines(lwd = .1, col = 'black') +
tm_shape(londonrail) + 
  tm_lines(lwd = .1, col = 'black') + 
tm_facets(ncol = ceiling(ncol(results_lwr02_pvals_spatial@data) / 3), nrow = floor(ncol(results_lwr02_pvals_spatial) / 3), sync = T) + 
tm_layout(legend.position = c('left','bottom'), outer.margins = c(0,0,0,0), legend.text.size = 1.5, legend.title.size = 1.5, frame = F)
```
## Compile regression results table
```{r}
regressiontable <- matrix(nrow = length(ivs), ncol = 8, dimnames = list(c(ivs),c('OLS with Spillovers','OLS with Spillovers 95CI_L','OLS with Spillovers 95CI_U','LWR Min','LWR 25%','LWR 50%','LWR 75%','LWR Max')))
for (row in rownames(regressiontable)) {  
  lwr_quantiles <- round(summary(results_lwr02$results_coef[,row]),3)
  regressiontable[row,'LWR Min'] <- lwr_quantiles[1]
  regressiontable[row,'LWR 25%'] <- lwr_quantiles[2]
  regressiontable[row,'LWR 50%'] <- lwr_quantiles[3]
  regressiontable[row,'LWR 75%'] <- lwr_quantiles[5]
  regressiontable[row,'LWR Max'] <- lwr_quantiles[6]
}

rownames(regressiontable)[1] <- '(Intercept)'
for (row in rownames(regressiontable)) {
  regressiontable[row,'OLS with Spillovers'] <- round(lm_global_local_spillovers$coefficients[row],3)
  regressiontable[row,'OLS with Spillovers 95CI_L'] <- round(confint(lm_global_local_spillovers)[row,1],3)
  regressiontable[row,'OLS with Spillovers 95CI_U'] <- round(confint(lm_global_local_spillovers)[row,2],3)
}

```

## Write out useful data
```{r}
write.csv(results_lwr02$results_coef, 'results_lwr02_coefs.csv')
write.csv(regressiontable, 'regressiontable.csv')
```

